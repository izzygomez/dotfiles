#!/bin/zsh

################################################################################
# Source checkers.sh
################################################################################

# Note: this should be updated if the location of this file changes within the
# dotfiles repo.
dotfiles_dir=$(dirname $(dirname $(realpath ~/.zshrc)))
source $dotfiles_dir/zsh/checkers.sh

################################################################################
# Powerlevel10k ('p10k') prompt configuration.
################################################################################

# TODO: The brew check below is specific to macOS. Consider making this more
# general to support other platforms (e.g. Linux) where p10k might be installed
# differently.
__p10k_enabled=false
if [[ -f ~/.p10k.zsh ]] && [[ -f $(brew --prefix)/share/powerlevel10k/powerlevel10k.zsh-theme ]]; then
    __p10k_enabled=true
fi

if $__p10k_enabled; then
    # Enable p10k instant prompt. Should stay close to the top of ~/.zshrc.
    # Initialization code that may require console input (password prompts, [y/n]
    # confirmations, etc.) must go above this block; everything else may go below.
    if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${USER}.zsh" ]]; then
        source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${USER}.zsh"
    fi

    # Doing this `source` per instructions in README [1]
    # [1] https://github.com/romkatv/powerlevel10k/blob/efc9ddd9b615a0042b5bcc36f97f070ca6fdf09e/README.md#homebrew
    source $(brew --prefix)/share/powerlevel10k/powerlevel10k.zsh-theme

    # To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
    source ~/.p10k.zsh

    # set ZSH_THEME to empty
    export ZSH_THEME=""
else
    echo "~/.zshrc: p10k theme not installed or missing configuration, falling back to setting oh-my-zsh theme."
    # Fall back to an oh-my-zsh theme if p10k isn't available.
    export ZSH_THEME="robbyrussell"
fi

################################################################################
# Oh My Zsh configuration.
#
# I deleted most of the commented out template lines that were not being used;
# see file in omz repo here:
# https://github.com/ohmyzsh/ohmyzsh/blob/master/templates/zshrc.zsh-template
#
# Note: I considered removing oh-my-zsh entirely as a dependency, but I quickly
# realized that it sets up a lot of nice things that I'd otherwise have to
# manually configure. For now I'm going to keep it, but note that no theme will
# be set here if the other themes are set up(see p10k sections).
#
# To be more explicit: the oh-my-zsh startup script loads in a bunch of lib
# files [1] that are extremely useful. This includes things like being able to
# `cd` without typing `cd`, having a `l` alias, git aliases, referencing parent
# directories with `.....`, & more that I haven't even discovered yet. Maybe in
# the future I can work towards removing oh-my-zsh as a dependency, but for now
# I'll just make it a bit more invisible by setting its update frequency to only
# happen every 60 days.
#
# [1] https://github.com/ohmyzsh/ohmyzsh/blob/028d65363230b4aa54f3aaa14e03237243a2f1d8/oh-my-zsh.sh#L195-L200
################################################################################

export OH_MY_ZSH="$HOME/.oh-my-zsh"

if [[ -d $OH_MY_ZSH ]]; then
    # See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes
    # ZSH_THEME="robbyrussell"  # commented out, set up above in p10k section
    plugins=(git)

    # Set the oh-my-zsh update frequency to 60 days. This must be set before
    # sourcing the oh-my-zsh script.
    zstyle ':omz:update' frequency 60
    zstyle ':omz:update' verbose minimal

    source $OH_MY_ZSH/oh-my-zsh.sh
else
    echo "~/.zshrc: oh-my-zsh not installed at $OH_MY_ZSH, please visit https://ohmyz.sh/ to install."
fi

################################################################################
# All machines configuration
#
# This configuration should apply to all synchronized machines that make use of
# https://github.com/izzygomez/dotfiles or
# https://github.com/izzygomez/mac-setup
################################################################################

alias x='exit'

alias code='cd "$HOME/code"'

if is_command_available emacs; then
    source $dotfiles_dir/zsh/zshrc_emacs
else
    echo "~/.zshrc: emacs is not available, can't set settings."
fi

if is_command_available less; then
    source $dotfiles_dir/zsh/zshrc_less
else
    echo "~/.zshrc: less is not available, can't set settings."
fi

# makes ^R backward search support patterns (i.e. '*' characters)
bindkey '^R' history-incremental-pattern-search-backward

if is_command_available git; then
    source $dotfiles_dir/zsh/zshrc_git
else
    echo "~/.zshrc: git is not available, can't set settings."
fi

if is_command_available tmux; then
    # Some useful & opinionated tmux aliases
    alias tl='tmux ls'
    alias tk='tmux kill-server'

    # Create a new tmux session with a blank window in "~"
    # Usage:
    # > {tn,tmuxnew} [session-name]
    # > t # no need to specify a session name
    alias t='tmux new -n "" -c "~"'
    alias tmuxnew='tmux new -n "" -c "~" -s'
    alias tn='tmuxnew'

    # Attach to a tmux session while detaching any other clients
    alias tmuxattach='tmux attach -dt'
    alias ta='tmuxattach'
else
    echo "~/.zshrc: tmux is not available, can't set settings."
fi

if is_command_available grep; then
    # `grep` niceties: ignore case, colored output
    alias grep='grep --ignore-case --color=auto'
else
    echo "~/.zshrc: grep is not available, can't set settings."
fi

if is_command_available eza; then
    # `eza` [1] seems like it can be dropped in as a replacement for `ls`, so
    # going to default to using it, with some opinionated defaults.
    # [1] https://github.com/eza-community/eza
    alias ls='eza --git --group-directories-first'
else
    echo "~/.zshrc: eza is not available, can't set settings."
fi

if is_command_available bat; then
    # `bat` [1] seems like it can be dropped in as a replacement for `cat`, so
    # going to default to using it, with some opinionated defaults.
    # [1] https://github.com/sharkdp/bat
    alias bat='bat --paging=always'
    alias b='bat'
    alias cat='bat'
else
    echo "~/.zshrc: bat is not available, can't set settings."
fi

# zsh history configuration
source $dotfiles_dir/zsh/zshrc_history

# Command line weather widget
weather() {
    if [ "$1" = "--help" ]; then
        echo "Usage: weather [location]"
        echo "Display the weather information for a specified location."
        echo "If no location is specified, the weather for the current location is displayed."
        echo "Example: weather 'Brooklyn, NY'"
        echo "         weather 'San Francisco, CA'"
        return
    fi

    get_location() {
        # Use ipinfo.io to get geolocation data; this is useful to do because
        # sometimes when using a VPN `curl wttr.in` returns a `not found` error,
        # so here we force a location name every time according to IP location.
        ipinfo=$(curl -s ipinfo.io)
        city=$(echo "$ipinfo" | grep '"city"' | awk -F '"' '{print $4}')
        region=$(echo "$ipinfo" | grep '"region"' | awk -F '"' '{print $4}')
        echo "$city,$region"
    }

    if [ -n "$1" ]; then
        location=$(echo "$1" | sed 's/ /+/g') # replace spaces with "+" in url
    else
        location=$(get_location)
        if [ -z "$location" ]; then
            echo "Error: Unable to determine location. Please specify a location or disable VPN."
            return
        fi
        location=$(echo "$location" | sed 's/ /+/g') # replace spaces with "+" in url
    fi

    # `?u` ensures F¬∞ units are used [1]
    # [1] https://github.com/chubin/wttr.in?tab=readme-ov-file#weather-units
    # note: separating `url` definition bc of weird behavior when adding a `?Y`
    # string after a `$X` string.
    url="wttr.in/$location"
    response=$(curl -s "$url?u")

    error="Weather report: not found"
    if echo "$response" | grep -q "$error"; then
        echo "Error: saw '$error' in response; maybe disable VPN?"
        return
    else
        echo "$response"
        return
    fi
}

# Added as part of pyenv install instructions [1]. On macOS, should be installed
# via `brew`; elsewhere follow these instructions [2].
# [1] https://github.com/pyenv/pyenv#set-up-your-shell-environment-for-pyenv
# [2] https://github.com/pyenv/pyenv-installer
export PYENV_ROOT="$HOME/.pyenv"
is_command_available pyenv || export PATH="$PYENV_ROOT/bin:$PATH"
if is_command_available pyenv; then
    eval "$(pyenv init -)"
else
    echo "~/.zshrc: pyenv is not available, can't set settings."
fi

# Load Rust environment if installed
[ -f "$HOME/.cargo/env" ] && . "$HOME/.cargo/env"

# Added per instructions (7) while setting up GPG keys for git commits
# https://docs.github.com/en/authentication/managing-commit-signature-verification/telling-git-about-your-signing-key#telling-git-about-your-gpg-key
export GPG_TTY=$(tty)

# Added automatically from install script:  https://github.com/nvm-sh/nvm#installing-and-updating
# Note that these lines aren't inside the `if` block because (1) they fail
# gracefully if nvm is not installed, & (2) they are needed for `nvm` to be
# available in the first place.
export NVM_DIR="$HOME/.nvm"
# This loads nvm
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
# This loads nvm bash_completion
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
if ! is_command_available nvm; then
    echo "~/.zshrc: nvm is not available."
fi

# Standardize pasting in zsh by making Ctrl-Y/C-y behave the same as pasting
# from system clipboard. This removes the emacs-style "yank last killed text"
# default behavior, which I don't use anyways.
yank_from_clipboard() {
    # Insert text from the system clipboard.
    if is_mac_os; then
        LBUFFER+=$(pbpaste)
    elif is_linux; then
        # TODO: impl
        echo "~/.zshrc: yank_from_clipboard not implemented on linux."
    else
        echo "~/.zshrc: not a recognized machine, not setting yank_from_clipboard."
    fi
}
# declare custom function as a ZLE widget
zle -N yank_from_clipboard
# bind C-Y to yank_from_clipboard. Note that "emacs" appears here because the
# emacs keymap mode is the default editing mode in zsh.
bindkey -M emacs "^Y" yank_from_clipboard

# TODO: do similar operation for C-W, M-W, & backspace commands in zsh.
# Specifically, right now C-W ("cut") & M-W ("copy") aren't working as I'd like
# them to when highlighting text inside the zsh command prompt when *not* inside
# copy mode. While we're at it, also make it so that if a region of text is
# highlighted & I press backspace, the entire block is deleted, not just the
# where the cursor was last at.

man() {
    local zsh_builtins=(
        alias autoload bg bindkey break builtin bye cap cd chdir clone command
        comparguments compcall compctl compdescribe compfiles compgroups compquote
        comptags comptry compvalues continue declare dirs disable disown echo echotc
        echoti emulate enable eval exec exit export false fc fg float functions
        getcap getln getopts hash history integer jobs kill let limit local log
        logout noglob popd print printf pushd pushln pwd r read readonly rehash
        return sched set setcap setopt shift source stat suspend test times trap
        true ttyctl type typeset ulimit umask unalias unfunction unhash unlimit
        unset unsetopt vared wait whence where which zcompile zformat zftp zle
        zmodload zparseopts zprof zpty zregexparse zsocket zstyle ztcp
    )

    if echo " ${zsh_builtins[*]} " | grep -q " $1 "; then
        echo "Note: '$1' is a zsh builtin, so \`man $1\` may not show proper documentation." >&2
        echo "Consider running \`man zshbuiltins\` & searching for '$1' instead." >&2
    fi

    command man "$@"
}

################################################################################
# Machine-specific configurations
################################################################################

# Set prompt emoji prefixes to differentiate different machines.
if is_izzys_mba; then
    __prompt_emoji='üí® '
elif is_izzys_mbp; then
    __prompt_emoji='üöÄ '
elif is_izzys_metro_mbp; then
    __prompt_emoji='üè¢ '
elif is_izzys_raspberry_pi; then
    # Note: considering I mostly `mosh` into this machine & mosh has a long
    # history of not supporting certain emojis/characters [1], I'm limited in
    # what I can use here.
    # [1] https://github.com/mobile-shell/mosh/issues/234
    __prompt_emoji='ü§ñ '
else
    echo "~/.zshrc: not a recognized machine, not setting prompt prefix."
fi
# Apply the emoji using p10k if available, otherwise fall back to PROMPT.
if [[ -n $__prompt_emoji ]]; then
    if $__p10k_enabled; then
        # p10k is active; use its mechanism to add emoji before the prompt char.
        typeset -g POWERLEVEL9K_MULTILINE_LAST_PROMPT_PREFIX="$__prompt_emoji"
    else
        # Fallback for non-p10k prompts (e.g. oh-my-zsh theme).
        PROMPT="$__prompt_emoji$PROMPT"
    fi
fi

# Raspberry Pi specific configuration.
if is_raspberry_pi; then
    source $dotfiles_dir/zsh/zshrc_raspberry_pi
fi

# Corp laptop specific configuration.
if is_izzys_metro_mbp && [ -f "$dotfiles_dir/zsh/zshrc_metro" ]; then
    source "$dotfiles_dir/zsh/zshrc_metro"
fi
# this is set in zshrc_metro, which is in .gitignore, so we default to an empty
# string here to avoid errors when trying to use it in `~/.npmrc`.
export NPM_METRONOME_TOKEN="${NPM_METRONOME_TOKEN:-}"

# Mac OS specific configuration.
# See bottom of `zshrc_macos` for why this must be sourced last.
if is_mac_os; then
    source $dotfiles_dir/zsh/zshrc_macos
fi
# NOTHING SHOULD BE ADDED BELOW THIS LINE
