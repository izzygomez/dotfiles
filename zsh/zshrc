#!/bin/zsh

################################################################################
# Source checkers.sh
################################################################################

# Note: this should be updated if the location of this file changes within the
# dotfiles repo.
dotfiles_dir=$(dirname $(dirname $(realpath ~/.zshrc)))
source $dotfiles_dir/zsh/checkers.sh

################################################################################
# Pure prompt configuration.
################################################################################

# Check if Pure [1] is installed; if not, fallback to setting an oh-my-zsh theme.
#
# This `autoload...` line is from the "Getting Started" section of the pure
# README [1], but it's also necessary here to load all prompt_*_setup functions
# to do appropriate check below. For more context, see [2].
#
# [1] https://github.com/sindresorhus/pure?tab=readme-ov-file#install
# [2] https://chatgpt.com/share/678fe919-c960-800c-88e3-088be26ec2d9
autoload -U promptinit; promptinit
if (( $+functions[prompt_pure_setup] )); then
    # This line from README [1]
    prompt pure

    # The rest in this code block is custom formatting.
    # colors:
    zstyle :prompt:pure:path color '#ADD8E6'
    zstyle :prompt:pure:prompt:success color green
    # show git stash with symbol â‰¡:
    zstyle :prompt:pure:git:stash show yes

    # set ZSH_THEME to empty, per [1]
    export ZSH_THEME=""
else
    echo "~/.zshrc: pure prompt not installed, falling back to setting oh-my-zsh theme."
    # Fall back to an oh-my-zsh theme if Pure isn't available.
    export ZSH_THEME="robbyrussell"
fi

################################################################################
# Oh My Zsh configuration.
#
# TODO: I just realized it's *assumed* that oh-my-zsh is installed on any
# machine that uses this dotfiles repo, which may not be true. Fix this, either
# by enforcing oh-my-zsh is installed for rest of `~/.zshrc` file to load, or
# by setting up a fallback (& logging an appropriate error message).
#
# I deleted most of the commented out template lines that were not being used;
# see file in omz repo here:
# https://github.com/ohmyzsh/ohmyzsh/blob/master/templates/zshrc.zsh-template
#
# Note: I considered removing oh-my-zsh entirely as a dependency, but I quickly
# realized that it sets up a lot of nice things that I'd otherwise have to
# manually configure. For now I'm going to keep it, but note that no theme will
# be set here since I'm using the `pure` prompt (see next section).
#
# To be more explicit: the oh-my-zsh startup script loads in a bunch of lib
# files [1] that are extremely useful. This includes things like being able to
# `cd` without typing `cd`, having a `l` alias, git aliases, referencing parent
# directories with `.....`, and more that I haven't even discovered yet. Maybe
# in the future I can work towards removing oh-my-zsh as a dependency, but for
# now I'll just make it a bit more invisible by setting its update frequency to
# only happen every 60 days.
#
# [1] https://github.com/ohmyzsh/ohmyzsh/blob/028d65363230b4aa54f3aaa14e03237243a2f1d8/oh-my-zsh.sh#L195-L200
################################################################################

export ZSH="$HOME/.oh-my-zsh"
# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes
# ZSH_THEME="robbyrussell"  # commented out, set up above in Pure section
plugins=(git)

# Set the oh-my-zsh update frequency to 60 days. This must be set before
# sourcing the oh-my-zsh script.
zstyle ':omz:update' frequency 60
zstyle ':omz:update' verbose minimal

source $ZSH/oh-my-zsh.sh

################################################################################
# All machines configuration
#
# This configuration should apply to all synchronized machines that make use of
# https://github.com/izzygomez/dotfiles or
# https://github.com/izzygomez/mac-setup
################################################################################

if is_command_available emacs; then
    source $dotfiles_dir/zsh/zshrc_emacs
else
    echo "~/.zshrc: emacs is not available, can't set settings."
fi

# makes ^R backward search support patterns (i.e. '*' characters)
bindkey '^R' history-incremental-pattern-search-backward

if is_command_available git; then
    # Git commit graph alias
    # https://tech.serhatteker.com/post/2021-02/git-log-tree/
    alias gitgraph='git log --graph --pretty='\''%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset'\'' --all'
    alias ggr='gitgraph'
else
    echo "~/.zshrc: git is not available, can't set settings."
fi

if is_command_available tmux; then
    # Some useful & opinionated tmux aliases
    alias tl='tmux ls'
    alias tk='tmux kill-server'

    # Create a new tmux session with a blank window in "~"
    # Usage:
    # > {tn,tmuxnew} [session-name]
    # > t # no need to specify a session name
    alias t='tmux new -n "" -c "~"'
    alias tmuxnew='tmux new -n "" -c "~" -s'
    alias tn='tmuxnew'

    # Attach to a tmux session while detaching any other clients
    alias tmuxattach='tmux attach -dt'
    alias ta='tmuxattach'
else
    echo "~/.zshrc: tmux is not available, can't set settings."
fi

# Shortcuts for having a browsable history, with date & time stamps.
# `h` is for the entire history, `ht N` is for the last N lines.
alias h='history -f | less'
__history_tail() {
    if [ -z "$1" ]; then
        echo "Usage: ht {number of lines}"
        return 1
    fi
    history -f | tail -n $1 | less
}
alias ht=__history_tail

# Command line weather widget
weather() {
    if [ "$1" = "--help" ]; then
        echo "Usage: weather [location]"
        echo "Display the weather information for a specified location."
        echo "If no location is specified, the weather for the current location is displayed."
        echo "Example: weather 'Brooklyn, NY'"
        echo "         weather 'San Francisco, CA'"
        return
    fi

    get_location() {
        # Use ipinfo.io to get geolocation data; this is useful to do because
        # sometimes when using a VPN `curl wttr.in` returns a `not found` error,
        # so here we force a location name every time according to IP location.
        ipinfo=$(curl -s ipinfo.io)
        city=$(echo "$ipinfo" | grep '"city"' | awk -F '"' '{print $4}')
        region=$(echo "$ipinfo" | grep '"region"' | awk -F '"' '{print $4}')
        echo "$city,$region"
    }

    if [ -n "$1" ]; then
        location=$(echo "$1" | sed 's/ /+/g') # replace spaces with "+" in url
    else
        location=$(get_location)
        if [ -z "$location" ]; then
            echo "Error: Unable to determine location. Please specify a location or disable VPN."
            return
        fi
        location=$(echo "$location" | sed 's/ /+/g') # replace spaces with "+" in url
    fi

    # `?u` ensures FÂ° units are used [1]
    # [1] https://github.com/chubin/wttr.in?tab=readme-ov-file#weather-units
    # note: separating `url` definition bc of weird behavior when adding a `?Y`
    # string after a `$X` string.
    url="wttr.in/$location"
    response=$(curl -s "$url?u")

    error="Weather report: not found"
    if echo "$response" | grep -q "$error"; then
        echo "Error: saw '$error' in response; maybe disable VPN?"
	return
    else
        echo "$response"
	return
    fi
}

# Added as part of pyenv install instructions [1]. On macOS, should be installed
# via `brew`; elsewhere follow these instructions [2].
# [1] https://github.com/pyenv/pyenv#set-up-your-shell-environment-for-pyenv
# [2] https://github.com/pyenv/pyenv-installer
export PYENV_ROOT="$HOME/.pyenv"
command -v pyenv >/dev/null || export PATH="$PYENV_ROOT/bin:$PATH"
if is_command_available pyenv; then
    eval "$(pyenv init -)"
else
    echo "~/.zshrc: pyenv is not available, can't set settings."
fi

# Added per instructions (7) while setting up GPG keys for git commits
# https://docs.github.com/en/authentication/managing-commit-signature-verification/telling-git-about-your-signing-key#telling-git-about-your-gpg-key
export GPG_TTY=$(tty)

# Added automatically from install script:  https://github.com/nvm-sh/nvm#installing-and-updating
# Note that these lines aren't inside the `if` block because (1) they fail
# gracefully if nvm is not installed, and (2) they are needed for `nvm` to be
# available in the first place.
export NVM_DIR="$HOME/.nvm"
# This loads nvm
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
# This loads nvm bash_completion
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
if ! is_command_available nvm; then
    echo "~/.zshrc: nvm is not available."
fi

# Created the following by working with ChatGPT. Also had it write out super
# detailed comments so it's easier to understand later on.
#
# Define a custom wrapper for the `less` command that shows the full file path
# (or "[stdin]" for streams) in the prompt, along with visible line ranges and
# the total line count when possible.
less_with_full_path() {
    # Define a local variable to store the file path or stream indicator
    local real_file_path

    # Check if the first argument to the function ($1) is provided
    if [ -n "$1" ]; then
	# If a file is passed as the first argument:
	# - Resolve its absolute path using `realpath`
	# - Replace the home directory path ($HOME) with a tilde (~) for brevity
	# - Suppress any errors from `realpath` (e.g., if the file doesn't
	#   exist) using `2>/dev/null`
	real_file_path=$(realpath "$1" 2>/dev/null | sed "s|$HOME|~|")
    else
	# If no file is passed (i.e., input is a stream or pipe):
	# Use "[stdin]" as the file path placeholder
	real_file_path="[stdin]"
    fi

    # Check if the provided argument is a regular file (not a stream or pipe)
    if [ -f "$1" ]; then
	# If it's a regular file:
	# - Precompute the total number of lines in the file using `wc -l`
	# - Remove any leading whitespace from `wc -l` output using `tr -d ' '`
	local total_lines=$(wc -l < "$1" | tr -d ' ')

	# Call the `less` command with the following options:
	# - `-R`: Display raw control characters, allowing for syntax
	#         highlighting
	# - `-j1`: Set the cursor position to the first visible line (top of the
	#          screen)
	# - `-P`: Customize the prompt to show:
	#     1. Full file path (or "~" for home directory)
	#     2. Current visible line range (`%lt` for top line, `%lb` for
	#        bottom line)
	#     3. Total line count (precomputed via `wc -l`)
	command less -R -j1 -P"$real_file_path (lines %lt-%lb/$total_lines)" "$@"
    else
	# If it's a stream or pipe (not a regular file):
	# - Use `%L` for total line count, which `less` calculates dynamically
	#   once it reaches the end of the stream.
	# - The prompt will display:
	#     1. "[stdin]" as the file path
	#     2. Current visible line range (`%lt` for top line, `%lb` for
	#        bottom line)
	#     3. Total line count (`%L`), dynamically updated as `less`
	#        processes input
	command less -R -j1 -P"$real_file_path (lines %lt-%lb/%L)" "$@"
    fi
}

# Create an alias for `less` to automatically use the custom function
# This ensures any call to `less` (e.g., `less somefile`, `seq 1 100 | less`)
# uses the wrapper
alias less='less_with_full_path'

################################################################################
# Machine-specific configuration
################################################################################

# Set prompt emoji prefixes to differentiate different machines.
if is_izzys_mba; then
    PROMPT='ðŸ’¨ '$PROMPT
elif is_izzys_mbp; then
    PROMPT='ðŸš€ '$PROMPT
elif is_izzys_raspberry_pi; then
    # Note: considering I mostly `mosh` into this machine & mosh has a long
    # history of not supporting certain emojis/characters [1], I'm limited in
    # what I can use here.
    # [1] https://github.com/mobile-shell/mosh/issues/234
    PROMPT='ðŸ¤– '$PROMPT
else
    echo "~/.zshrc: not a recognized machine, not setting prompt prefix."
fi

# Raspberry Pi specific configuration.
if is_raspberry_pi; then
    source $dotfiles_dir/zsh/zshrc_raspberry_pi
fi

# Mac OS specific configuration; see zshrc_macos for details, but this must be
# sourced last.
if is_mac_os; then
    source $dotfiles_dir/zsh/zshrc_macos
fi
