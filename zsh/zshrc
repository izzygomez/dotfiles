#!/bin/zsh

################################################################################
# Source checkers.sh
################################################################################

# Note: this should be updated if the location of this file changes within the
# dotfiles repo.
dotfiles_dir=$(dirname $(dirname $(realpath ~/.zshrc)))
source $dotfiles_dir/zsh/checkers.sh

################################################################################
# Pure prompt configuration.
################################################################################

# Check if Pure [1] is installed; if not, fallback to setting an oh-my-zsh theme.
#
# This `autoload...` line is from the "Getting Started" section of the pure
# README [1], but it's also necessary here to load all prompt_*_setup functions
# to do appropriate check below. For more context, see [2].
#
# [1] https://github.com/sindresorhus/pure?tab=readme-ov-file#install
# [2] https://chatgpt.com/share/678fe919-c960-800c-88e3-088be26ec2d9
autoload -U promptinit
promptinit
# Note: this line used to be the following [1], but it would break with `shfmt`
# formatting in .pre-commit-config.yaml, since this line is zsh syntax but
# `shfmt` is technically only supports bash syntax. Rewrote the logic to get
# around this small limitation, but keeping [1] around for reference, since [1]
# is what was recommended by ChatGPT in conversation above [2].
# [1] `if (( $+functions[prompt_pure_setup] )); then`
if [[ -n ${functions[prompt_pure_setup]} ]]; then
    # This line from README [1]
    prompt pure

    # Hack to suppress Pure's newline on first prompt only. See this thread [1]
    # for context on author's opinion on the matter & a workaround that inspired
    # this implementation. Note that this works for new lines in a new tab, tmux
    # pane/window, etc, & also when running `clear`.
    # [1] https://github.com/sindresorhus/pure/issues/509
    __pure_first_prompt=1
    print() {
        if [ 0 -eq $# -a "prompt_pure_precmd" = "${funcstack[-1]}" ]; then
            # Pure is trying to print its preprompt newline
            if [[ $__pure_first_prompt -eq 1 ]]; then
                __pure_first_prompt=0
                # Suppress on first prompt
            else
                # Allow on subsequent prompts
                builtin print "$@"
            fi
        else
            # Normal print call, pass through
            builtin print "$@"
        fi
    }

    # Reset flag when clear is run so next prompt has no newline
    clear() {
        __pure_first_prompt=1
        command clear
    }

    # The rest in this code block is custom formatting.
    # colors:
    zstyle :prompt:pure:path color '#ADD8E6'
    zstyle :prompt:pure:prompt:success color green
    # show git stash with symbol ‚â°:
    zstyle :prompt:pure:git:stash show yes

    # set ZSH_THEME to empty, per [1]
    export ZSH_THEME=""
else
    echo "~/.zshrc: pure prompt not installed, falling back to setting oh-my-zsh theme."
    # Fall back to an oh-my-zsh theme if Pure isn't available.
    export ZSH_THEME="robbyrussell"
fi

################################################################################
# Oh My Zsh configuration.
#
# I deleted most of the commented out template lines that were not being used;
# see file in omz repo here:
# https://github.com/ohmyzsh/ohmyzsh/blob/master/templates/zshrc.zsh-template
#
# Note: I considered removing oh-my-zsh entirely as a dependency, but I quickly
# realized that it sets up a lot of nice things that I'd otherwise have to
# manually configure. For now I'm going to keep it, but note that no theme will
# be set here if the `pure` prompt is available (see prior section).
#
# To be more explicit: the oh-my-zsh startup script loads in a bunch of lib
# files [1] that are extremely useful. This includes things like being able to
# `cd` without typing `cd`, having a `l` alias, git aliases, referencing parent
# directories with `.....`, & more that I haven't even discovered yet. Maybe in
# the future I can work towards removing oh-my-zsh as a dependency, but for now
# I'll just make it a bit more invisible by setting its update frequency to only
# happen every 60 days.
#
# [1] https://github.com/ohmyzsh/ohmyzsh/blob/028d65363230b4aa54f3aaa14e03237243a2f1d8/oh-my-zsh.sh#L195-L200
################################################################################

export ZSH="$HOME/.oh-my-zsh"

if [[ -d $ZSH ]]; then
    # See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes
    # ZSH_THEME="robbyrussell"  # commented out, set up above in Pure section
    plugins=(git)

    # Set the oh-my-zsh update frequency to 60 days. This must be set before
    # sourcing the oh-my-zsh script.
    zstyle ':omz:update' frequency 60
    zstyle ':omz:update' verbose minimal

    source $ZSH/oh-my-zsh.sh
else
    echo "~/.zshrc: oh-my-zsh not installed at $ZSH, please visit https://ohmyz.sh/ to install."
fi

################################################################################
# All machines configuration
#
# This configuration should apply to all synchronized machines that make use of
# https://github.com/izzygomez/dotfiles or
# https://github.com/izzygomez/mac-setup
################################################################################

if is_command_available emacs; then
    source $dotfiles_dir/zsh/zshrc_emacs
else
    echo "~/.zshrc: emacs is not available, can't set settings."
fi

if is_command_available less; then
    source $dotfiles_dir/zsh/zshrc_less
else
    echo "~/.zshrc: less is not available, can't set settings."
fi

# makes ^R backward search support patterns (i.e. '*' characters)
bindkey '^R' history-incremental-pattern-search-backward

if is_command_available git; then
    source $dotfiles_dir/zsh/zshrc_git
else
    echo "~/.zshrc: git is not available, can't set settings."
fi

if is_command_available tmux; then
    # Some useful & opinionated tmux aliases
    alias tl='tmux ls'
    alias tk='tmux kill-server'

    # Create a new tmux session with a blank window in "~"
    # Usage:
    # > {tn,tmuxnew} [session-name]
    # > t # no need to specify a session name
    alias t='tmux new -n "" -c "~"'
    alias tmuxnew='tmux new -n "" -c "~" -s'
    alias tn='tmuxnew'

    # Attach to a tmux session while detaching any other clients
    alias tmuxattach='tmux attach -dt'
    alias ta='tmuxattach'
else
    echo "~/.zshrc: tmux is not available, can't set settings."
fi

if is_command_available grep; then
    # `grep` niceties: ignore case, colored output
    alias grep='grep --ignore-case --color=auto'
else
    echo "~/.zshrc: grep is not available, can't set settings."
fi

if is_command_available eza; then
    # `eza` [1] seems like it can be dropped in as a replacement for `ls`, so
    # going to default to using it, with some opinionated defaults.
    # [1] https://github.com/eza-community/eza
    alias ls='eza --git --group-directories-first'
else
    echo "~/.zshrc: eza is not available, can't set settings."
fi

if is_command_available bat; then
    # `bat` [1] seems like it can be dropped in as a replacement for `cat`, so
    # going to default to using it, with some opinionated defaults.
    # [1] https://github.com/sharkdp/bat
    alias bat='bat --paging=always'
    alias b='bat'
    alias cat='bat'
else
    echo "~/.zshrc: bat is not available, can't set settings."
fi

# Shortcuts for having a browsable history, with date & time stamps.
# `h` is for the entire history, `ht N` is for the last N lines.
alias h='history -f | less'
__history_tail() {
    if [ -z "$1" ]; then
        echo "Usage: ht {number of lines}"
        return 1
    fi
    history -f | tail -n $1 | less
}
alias ht=__history_tail

# Command line weather widget
weather() {
    if [ "$1" = "--help" ]; then
        echo "Usage: weather [location]"
        echo "Display the weather information for a specified location."
        echo "If no location is specified, the weather for the current location is displayed."
        echo "Example: weather 'Brooklyn, NY'"
        echo "         weather 'San Francisco, CA'"
        return
    fi

    get_location() {
        # Use ipinfo.io to get geolocation data; this is useful to do because
        # sometimes when using a VPN `curl wttr.in` returns a `not found` error,
        # so here we force a location name every time according to IP location.
        ipinfo=$(curl -s ipinfo.io)
        city=$(echo "$ipinfo" | grep '"city"' | awk -F '"' '{print $4}')
        region=$(echo "$ipinfo" | grep '"region"' | awk -F '"' '{print $4}')
        echo "$city,$region"
    }

    if [ -n "$1" ]; then
        location=$(echo "$1" | sed 's/ /+/g') # replace spaces with "+" in url
    else
        location=$(get_location)
        if [ -z "$location" ]; then
            echo "Error: Unable to determine location. Please specify a location or disable VPN."
            return
        fi
        location=$(echo "$location" | sed 's/ /+/g') # replace spaces with "+" in url
    fi

    # `?u` ensures F¬∞ units are used [1]
    # [1] https://github.com/chubin/wttr.in?tab=readme-ov-file#weather-units
    # note: separating `url` definition bc of weird behavior when adding a `?Y`
    # string after a `$X` string.
    url="wttr.in/$location"
    response=$(curl -s "$url?u")

    error="Weather report: not found"
    if echo "$response" | grep -q "$error"; then
        echo "Error: saw '$error' in response; maybe disable VPN?"
        return
    else
        echo "$response"
        return
    fi
}

# Added as part of pyenv install instructions [1]. On macOS, should be installed
# via `brew`; elsewhere follow these instructions [2].
# [1] https://github.com/pyenv/pyenv#set-up-your-shell-environment-for-pyenv
# [2] https://github.com/pyenv/pyenv-installer
export PYENV_ROOT="$HOME/.pyenv"
is_command_available pyenv || export PATH="$PYENV_ROOT/bin:$PATH"
if is_command_available pyenv; then
    eval "$(pyenv init -)"
else
    echo "~/.zshrc: pyenv is not available, can't set settings."
fi

# Load Rust environment if installed
[ -f "$HOME/.cargo/env" ] && . "$HOME/.cargo/env"

# Added per instructions (7) while setting up GPG keys for git commits
# https://docs.github.com/en/authentication/managing-commit-signature-verification/telling-git-about-your-signing-key#telling-git-about-your-gpg-key
export GPG_TTY=$(tty)

# Added automatically from install script:  https://github.com/nvm-sh/nvm#installing-and-updating
# Note that these lines aren't inside the `if` block because (1) they fail
# gracefully if nvm is not installed, & (2) they are needed for `nvm` to be
# available in the first place.
export NVM_DIR="$HOME/.nvm"
# This loads nvm
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
# This loads nvm bash_completion
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
if ! is_command_available nvm; then
    echo "~/.zshrc: nvm is not available."
fi

# Standardize pasting in zsh by making Ctrl-Y/C-y behave the same as pasting
# from system clipboard. This removes the emacs-style "yank last killed text"
# default behavior, which I don't use anyways.
yank_from_clipboard() {
    # Insert text from the system clipboard.
    if is_mac_os; then
        LBUFFER+=$(pbpaste)
    elif is_linux; then
        # TODO: impl
        echo "~/.zshrc: yank_from_clipboard not implemented on linux."
    else
        echo "~/.zshrc: not a recognized machine, not setting yank_from_clipboard."
    fi
}
# declare custom function as a ZLE widget
zle -N yank_from_clipboard
# bind C-Y to yank_from_clipboard. Note that "emacs" appears here because the
# emacs keymap mode is the default editing mode in zsh.
bindkey -M emacs "^Y" yank_from_clipboard

# TODO: do similar operation for C-W, M-W, & backspace commands in zsh.
# Specifically, right now C-W ("cut") & M-W ("copy") aren't working as I'd like
# them to when highlighting text inside the zsh command prompt when *not* inside
# copy mode. While we're at it, also make it so that if a region of text is
# highlighted & I press backspace, the entire block is deleted, not just the
# where the cursor was last at.

################################################################################
# Machine-specific configurations
################################################################################

# Set prompt emoji prefixes to differentiate different machines.
if is_izzys_mba; then
    PROMPT='üí® '$PROMPT
elif is_izzys_mbp; then
    PROMPT='üöÄ '$PROMPT
elif is_izzys_metro_mbp; then
    PROMPT='üè¢ '$PROMPT
elif is_izzys_raspberry_pi; then
    # Note: considering I mostly `mosh` into this machine & mosh has a long
    # history of not supporting certain emojis/characters [1], I'm limited in
    # what I can use here.
    # [1] https://github.com/mobile-shell/mosh/issues/234
    PROMPT='ü§ñ '$PROMPT
else
    echo "~/.zshrc: not a recognized machine, not setting prompt prefix."
fi

# Raspberry Pi specific configuration.
if is_raspberry_pi; then
    source $dotfiles_dir/zsh/zshrc_raspberry_pi
fi

# Corp laptop specific configuration.
if is_izzys_metro_mbp && [ -f "$dotfiles_dir/zsh/zshrc_metro" ]; then
    source "$dotfiles_dir/zsh/zshrc_metro"
fi

# Mac OS specific configuration.
# See bottom of `zshrc_macos` for why this must be sourced last.
if is_mac_os; then
    source $dotfiles_dir/zsh/zshrc_macos
fi
# NOTHING SHOULD BE ADDED BELOW THIS LINE
